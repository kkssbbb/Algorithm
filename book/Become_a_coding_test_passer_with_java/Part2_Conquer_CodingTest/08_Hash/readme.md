# 해시
## 해시 개념
해시는 키를 통해 데이터에 바로 접근 할 수 있다.
해시는 해시 함수를 사용해 키를 해시값(인덱스)로 변환해 데이터를 저장해서 빠른 데이터 탐색을 제공하는 자료구조 이다.

## 해시 특징
1. 단방향으로 동작한다.
   - 키를통해 값을 찾을 수 있지만, 값을 통해 키를 찾을 수 없다.  

2. 값을 O(1)로 바로 찾을 수 있다.  
   - 키 자체가 해시 함수에 의해 값이있는 인덱스이기 떄문이다.    

3. 값을 인덱스로 활용하려면 적절한 변환 과정을 거쳐야한다.  
> 단방향으로 동작하는 해시의 특성으로 외부에 정보를 안전하게 제공된다는 특징이 있어서 네트워크 보안에서 많이 활용된다.

## 버킷(bucket)
- 해시테이블의 각 데이터를 버킷 이라고 부른다.
### 예시
### 해시 테이블  
| 해시 인덱스 | 버킷 내용         |
|:-----------:|:-----------------|
|      0      | 12, 44           |
|      1      | 23               |
|      2      | (비어있음)        |
|      3      | 39, 56, 72       |

- 위 표에서 각 칸(0~3)이 **버킷**이며, 하나의 버킷에 여러 데이터가 들어갈 수 있다.

## 해시 특성을 활용하는 분야  
데이터를 저장하고 검색, 보안이 필요할때활용된다.  
코딩테스트에서는 특정 데이터를 탐색하는 횟수가 많을 경우 해시를 고려하면 좋다.  
### 해시 활용 실제 사례
1. 비밀번호관리
2. 데이터베이스 인덱싱
3. 블록체인

</br>
</br>

# 해시 함수
> 자바에서는 해시셋, 해시맵 이라는 표준 API를 제공하여 해시와 거의 동일하게 동작함으로 해시를 쉽게 사용할 수 있다.

## 해시 함수를 구현할 떄 고려할 내용
> 코딩테스트에서 해시 함수를 직접 구현하는 문제도 나오지않고 자바에서 해시셋 해시맵으로 쉽게 해시를 사용 할 수 있지만 해시의 원리를 이해하여 좀더 효율적으로 사용할 수 있다.

1. 해시함수의 변환 값은 해시테이블의 크기를 넘으면 안된다.
  - 예를들어 해시테이블 크기가 N이라면 해시함수의 변환값은 0~N-1 사이의 값을 내야한다.
2. 해시 함수가 변환한 값의 충돌은 최대한 적게 발생해야한다.
  - 충돌의 의미는 서로다른 두 키에대해 해싱 함수가 적용한 결과가 동일한것을 말한다. 
  - 즉, 해시는 충돌이라는 문제를 갖고있고, 이를 해결하기위한 다양한 해쉬 함수를 만드는 전략이 있다.
> 충돌이 아예 발생하지 않는 해시함수는 거의 없다.

## 자주 사용하는 해시 함수
**나눗셈법(division method)** : 키를 소수로 나눈 나머지를 활용한다.
$$
h(k) = k \bmod M
$$
- 소수로 나누는 이유는 다른 수를 사용할 때보다 충돌이 적기 때문이다.
  - 키 % 소수 = 해싱값
  - mod 는 % 같은 모듈러 연산이라는 의미이다.  
  >모듈러연산 : 나머지를 취하는 연산 (%)을 모듈러 연산이라고 한다.

  </br>

**곱셈법(multiplication method)** : 곱셈법은 나눗셈법과 비슷하게 모듈러 연산을 활용하지만 소수는 활용하지 않는다.

$$
h(k) = \left\lfloor M \times (k \times A \bmod 1) \right\rfloor
$$
m: 최대 버킷의 개수, a: 황금비(gold ratio number)
>황금비: 수학적으로 임의의 길이를 두 부분으로 나누었을 때, 전체와 비율이 긴 부분과 짧은 부분의 비율과 같은 비율을 뜻한다.

**문자열 해싱** : 나눗셈법,곱셈법은 키의 자료형이 숫자일때고, 문자열 해싱은 키의 자료형이 문자열일 때도 사용할 수 있는 해시 함수이다.
$$
\text{hash}(s) = (s_0 \times p^0 + s_1 \times p^1 + s_2 \times p^2 + \cdots + s_{n-1} \times p^{n-1}) \bmod m
$$
- 문자열 해싱은 문자열의 문자를 숫자로 변환하고 이 숫자들을 다항식의 값으로 변환해서 해싱한다.

  

</br>
</br>

# 충돌 처리(Collision Handling)

## 1. 충돌의 정의
서로 다른 키에 대해 해시 함수 결과값이 동일하면 **충돌(Collision)** 발생  
→ 하나의 버킷에 2개 이상의 값을 저장할 수 없으므로 반드시 처리 필요

---

## 2. 체이닝(Chaining)
충돌 발생 시 동일 버킷 내에서 연결 리스트(LinkedList)로 데이터 저장

### 장단점 비교
| 장점 | 단점 |
|-------|------|
| **간단한 구현**<br>(연결 리스트 추가만으로 구현) | **메모리 오버헤드**<br>(포인터 저장 공간 필요) |
| **테이블 확장 불필요**<br>(이론적 무한 저장 가능) | **캐시 지역성 저하**<br>(메모리 비연속 접근) |
| **높은 적재율 허용**<br>(Load Factor ≥ 1 가능) | **최악의 경우 O(n) 성능**<br>(한 버킷에 데이터 집중 시) |

### Java HashMap의 o(n) 개선 전략
```
// Java 8+ HashMap 소스코드 상수
static final int TREEIFY_THRESHOLD = 8;  // 8개 이상 시 트리 변환
static final int UNTREEIFY_THRESHOLD = 6; // 6개 이하 시 리스트 복귀
```
- **동작 원리**:  
  버킷 내 노드가 `TREEIFY_THRESHOLD(=8)` 초과 시  
  연결 리스트 → **레드-블랙 트리**로 전환 → **O(log n)** 성능 보장
- **최적화 목적**:  
  해시 충돌 최악의 시나리오(예: Hash DoS 공격) 방어

---

## 3. 개방 주소법(Open Addressing)
충돌 발생 시 빈 버킷을 탐색(Probing)하여 데이터 저장

### 프로빙(Probing) 방법
#### ① 선형 탐사(Linear Probing)
$$
h(k, i) = (h(k) + i) \bmod M
$$

- **특징**: 구현 간단 but **클러스터링(Cluster)** 발생  
  > 클러스터: 충돌값이 특정 영역에 집중되는 현상
- **문제점**: 검색 성능 저하 및 2차 충돌 유발

#### ② 이중 해싱(Double Hashing)
$$
h(k, i) = \left( h_1(k) + i \times h_2(k) \right) \bmod M
$$

| 파라미터 | 설명 |
|----------|------|
| `h₁(k)` | 기본 해시 함수 |
| `h₂(k)` | 점프 간격 결정 함수 (≠0) |
| `i` | 충돌 횟수 |
| `M` | 해시 테이블 크기 (소수 권장) |

### 장점
- **군집화 최소화**: `h₂(k)`가 키마다 달라 균일한 분포
- **메모리 효율**: 별도 저장공간 없이 테이블 내부 처리
- **삽입 효율성**: 빈 버킷 신속 탐색

### 필수 조건
$$
\text{gcd}(h_2(k), M) = 1 \quad \text{(서로소)}
$$
→ 모든 버킷 탐색 보장 및 무한 루프 방지

---

## 4. 방법론 비교
| 기준          | 체이닝         | 개방 주소법     |
|---------------|----------------|-----------------|
| **저장 위치**  | 버킷 외부      | 버킷 내부       |
| **메모리 효율** | 낮음 (포인터)  | 높음            |
| **적재율**     | 높음 (≥1 가능) | 낮음 (≤0.7 권장)|
| **클러스터링** | 영향 없음      | 발생 가능       |

## HashMap ADT(Abstract Data Type) 정리표

| 연산(Operation) | 설명(Description) | 시간 복잡도(Time Complexity) | 비고(Notes) |
|-----------------|-------------------|------------------------------|-------------|
| **`put(key, value)`** | 키-값 쌍을 해시맵에 삽입/갱신 | **평균: O(1)**<br>최악: O(n) or O(log n) | 키 존재 시 값 갱신<br>충돌 시 처리 방식에 따라 성능 변동 |
| **`get(key)`** | 키에 해당하는 값 조회 | **평균: O(1)**<br>최악: O(n) or O(log n) | 키 미존재 시 `null` 반환<br>체이닝 시 체인 길이에 의존 |
| **`remove(key)`** | 키에 해당하는 항목 삭제 | **평균: O(1)**<br>최악: O(n) or O(log n) | 삭제 후 테이블 상태 유지 필요<br>(개방 주소법: 탈취 표시) |
| **`containsKey(key)`** | 키 존재 여부 확인 | **평균: O(1)**<br>최악: O(n) or O(log n) | `get(key) != null` 동등 |
| **`size()`** | 저장된 항목 개수 반환 | **O(1)** | 내부 카운터로 즉시 반환 |
| **`isEmpty()`** | 맵이 비었는지 확인 | **O(1)** | `size() == 0` 동등 |
| **`keys()`** | 모든 키 컬렉션 반환 | **O(n)** | 키 순서 보장 안 됨 |
| **`values()`** | 모든 값 컬렉션 반환 | **O(n)** | 중복 값 가능 |
| **`entries()`** | 모든 키-값 쌍 반환 | **O(n)** | `Map.Entry` 객체 컬렉션 |
| **`clear()`** | 모든 항목 삭제 | **O(n)** | 버킷 배열 초기화 |
| **`loadFactor()`** | 현재 적재율 계산 | **O(1)** | `size / capacity` |

### 주요 특성
1. **동작 보장 조건**
   - 키(Key): `null` 허용 여부 구현체 의존 (Java HashMap 허용)
   - 객체 키는 `equals()`와 `hashCode()` 오버라이딩 필수

2. **성능 영향 요소**
   - 해시 함수 품질: 불균등 분포 시 성능 저하
   - 적재율(Load Factor): 일반적으로 0.75 초과 시 성능 급감
   - 충돌 처리 방식: 체이닝 vs 개방 주소법

3. **최적화 전략**
   - 동적 리사이징: 적재율 임계값 도달 시 버킷 2배 확장
   - 트리화(Java): 체인 길이 8 초과 시 레드-블랙 트리 변환
   - 캐시 친화성: 개방 주소법이 일반적으로 캐시 효율 우수
